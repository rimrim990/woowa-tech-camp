# 우아한 테크 캠프 TIL - 2023.08.27 (일)

며칠동안 번아웃이 와서 `TIL` 작성에 소홀했다. 잘 하고 있는지 또 다시 혼란스웠지만, 공부하는 것 말고는 해결 방법이 없다 ~

며칠 안 남은 캠프 기간 동안 다시 마음을 다잡고 달려보자 !

## 인덱스와 락 (4)

### 서문

최근에 팀 프로젝트를 수행하면서 해결했던 이슈와 공부했던 내용에 대해 정리 !

### `@BatchSize`

쿼리 최적화를 위해 페이징을 적용하던 중 다음과 같은 경고 문구를 보게 되었다.

```
firstResult/maxResults specified with collection fetch; applying in memory
```
- 해당 문구는 `@OneToMany` 연관관계에서 `fetch join` 과 페이징을 함께 사용했을 때 발견할 수 있다
- 페이징이 DB 단에서 `limit` 를 사용해 일어나지 않고, 어플리케이션 메모리 단에서 일어나고 있음을 의미한다

즉, 의도했던 대로 `limit` 가 적용되지 않고 모든 데이터를 메모리로 가져온 후, 어플리케이션 단에서 페이징을 적용하고 있음을 의미한다
실제 수행된 쿼리도 아래와 같았다

```sql
Hibernate:
select
    distinct o1_0.id,
             o2_0...,
             o1_0...,
from
    orders o1_0
        left join
    order_items o2_0
    on o1_0.id=o2_0.order_id
where
    o1_0.member_id=?
  and o1_0.status=?
order by
    o1_0.id desc
```

**왜 페이징이 적용되지 않았을까?**

페이징이 적용되지 않은 이유는 `@OneToMany` 연관관계에 있다.
`One` 쪽에서 `Many` 로 조인을 수행하면 `Many` 의 수 만큼 `One` 쪽의 데이터 양이 불어나게 된다.
따라서 불어난 데이터에 `limit` 를 적용하면 예상과 다른 결과가 나올 것이다. 그렇기 때문에 `JPA` 에서는 데이터를 모두 가져온 후 메모리에서 페이징을 수행하는 것이다.

**해결방법**

1. 두 개의 쿼리로 분리한다
- `One` 에 `WHERE` 절을 적용하여 필요한 데이터를 조회한다
- `IN` 쿼리를 사용하여 이에 대응되는 `Many` 측의 데이터를 가져오고, 이를 어플리케이션에서 조립해준다
- 그러나 현재 프로젝트에서는 `@OneToMany` 단방향을 사용하고 있다. 따라서 `Many` 측에서는 `One` 을 알지 못하기 때문에 어플리케이션에서 조립이 불가능하다

2. `@BatchSize` 를 적용한다
- 해결 방법을 찾지 못해 팀원에게 물어봤고 이러한 해결 방법을 알 수 있었다 !
- `One` 측에 `@BatchSize` 를 적용하고 지연 로딩을 사용한다. 연관된 데이터를 조회할 때 `JPA` 에서 자동으로 `IN` 쿼리를 적용해준다.
```java
@Batch(size = 20) 
List<OrderItem> orderItems;
```
- `Order` 에 페이징을 적용하여 20개씩 가져오기 때문에 `Batch` 크기는 20으로 설정하였다
```sql
select
        o1_0...
    from
        order_items o1_0 
    where
        array_contains(?,o1_0.order_id)
```
- `o1_0.order_id` 가 array 타입인 `?` 에 포함되면 true 를 반환한다

### `MySQL` 실행계획 분석 (Real MySQL)

실행계획 분석을 위해 다음과 같은 쿼리를 작성하였다
```sql
explain select *, (po.quantity / oi.quantity) as rate from order_items oi
inner join products p on oi.product_id = p.id
inner join (
    	select order_id, quantity from order_items where order_items.product_id = 319
) as po on oi.order_id = po.order_id
where p.id != 319;
```

출력한 실행계획은 다음과 같다
```
+----+-------------+-------------+------------+--------+-----------------------------------------------------+-------------------------+---------+-------------------------------+------+----------+-------------+
| id | select_type | table       | partitions | type   | possible_keys                                       | key                     | key_len | ref                           | rows | filtered | Extra       |
+----+-------------+-------------+------------+--------+-----------------------------------------------------+-------------------------+---------+-------------------------------+------+----------+-------------+
|  1 | SIMPLE      | order_items | NULL       | ref    | idx_order_order_items,idx_product_order_items,idx_1 | idx_product_order_items | 8       | const                         | 1239 |   100.00 | Using where |
|  1 | SIMPLE      | oi          | NULL       | ref    | idx_order_order_items,idx_product_order_items,idx_1 | idx_order_order_items   | 9       | shopping.order_items.order_id |    2 |    56.62 | Using where |
|  1 | SIMPLE      | p           | NULL       | eq_ref | PRIMARY                                             | PRIMARY                 | 8       | shopping.oi.product_id        |    1 |   100.00 | NULL        |
+----+-------------+-------------+------------+--------+-----------------------------------------------------+-------------------------+---------+-------------------------------+------+----------+-------------+
3 rows in set, 1 warning (0.001 sec)
```

- 실행 계획의 각 라인은 쿼리 문장에서 사용된 테이블의 개수만큼 출력된다 (서브 쿼리로 임시 테이블을 생성한 경우 해당 테이블도 포함)
- 실행 순서는 위에서 아래대로 순서대로 표시된다 (UNION 이나 서브쿼리의 경우 순서대로 표시되지 않을 수 있음)
  - 위쪽에 출력된 결과일수록 쿼리의 바깥 (Outer) 부분이거나 먼저 접근한 테이블 

**`id`컬럼**
- `id`컬럼은 `SELECT` 컬럼별도 부여되는 식별자이다
- 하나의 `SELECT` 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 `id` 값이 부여된다

**`select_type`컬럼**
- 각 단위의 `SELECT` 쿼리가 어떤 타입의 쿼리인지 표시하는 컬럼이다
- SIMPLE : `UNION` 이나 서브쿼리를 사용하지 않은 단순한 `SELECT` 일 경우
- PRIMARY : `UNION` 이나 `SELECT` 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
- SUBQUERY : `FROM` 절 이외에서 사용되는 서브쿼리

**`type`컬럼**
- 테이블의 접근 방법을 의미한다. 아래의 `type` 컬럼 값은 실행 속도가 빠른 순서대로 나열하였다
- const : 테이블의 레코드 건수와 상관없이 쿼리가 프라이머리 키나 유니크 칼럼을 이용하는 `WHERE` 조건을 가지고 있으며, 반드시 1건만 반환하는 쿼리
  - 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행한 후 통째로 상수화
```sql
SELECT * FROM members WHERE id = 1; # id 는 members 테이블의 PK
```

- eq_ref : 조인 상황에서 처음 읽은 테이블의 칼럼 값을 그다음에 읽는 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용
  - 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방식
- ref : 조인의 순서와 관계 없이 사용되며, 인덱스외 종류와 관계 없이 동등 조건으로 검색할 때 사용
  - 레코드가 반드시 1건이라는 보장이 없으므로 `const` 나 `eq_ref` 보다는 빠르지 않다
  - 그러나 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법 중 하나
- range : 인덱스 레인지 스캔 형태의 접근 방식
- index : 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 접근 방식
  - 풀 테이블 스캔과 비교했을 때 비교하는 레코드의 수는 같지만, 인덱스는 테이블 파일 전체보다 크기가 작으모르 풀 테이블 스캔보다 빠르게 처리됨
  - 쿼리 내용에 따라 정렬된 인덱스의 장점을 이용할 수도 있음
  - 커버링 인덱스거나 인덱스를 이용해 정렬이나 그루핑 작업이 가능할 때 사용
- ALL : 인덱스를 사용하지 않는 풀 테이블 방식
  - 앞서 등장한 모든 접근 방법으로는 처리할 수 없을 때 가장 마지막에 선택되는 가장 비효율적인 방법

**`ref`컬럼**
- 참조 조건 (equal 비교 조건) 으로 어떤 값이 제공되었는지 보여준다
- 상숫값을 지정했다면 `ref` 값이 `const` 로 표시되고, 다른 테이블의 컬럼값이면 그 테이블명과 칼럼명이 표시된다

**`rows`컬럼**
- 실행 계획의 효율성 판단을 위해 예측했던 레코드의 건수를 보여준다
  - 스토리지 엔진의 통계 정볼르 참조해 `MySQL` 옵티마이저가 산출해 낸 예상값이므로 정확하진 않다
- 반환되는 쿼리의 예측치가 아니라 쿼리를 처리하기 위해 읽어야 할 레코드 수의 예측치이다

**`filtered`컬럼**
- 레코드를 스캔했을 때 필터링되고 남은 레코드의 비율을 의미한다

**`extra`컬럼**
- 내부적인 처리 알고리즘에 의해 더 깊이 있는 내용을 보여준다
- Using filesort : `ORDER BY` 를 처리하기 위한 적절한 인덱스를 사용하지 못할 때 서버가 조회한 레코드를 다시 한 번 정렬했음을 의미한다
  - 조회된 레코드를 메모리 버퍼에 복사해 정렬 알고리즘을 사용하여 정렬
- Using index : 커버링 인덱스. 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리르 모두 처리할 수 있음을 의미한다
  - InnoDB 의 모든 테이블은 클러스터링 인덱스로 구성되어 있으므로,세컨더리 인덱스의 리프 노드는 데이터의 주솟값으로 프라이머리 키 값을 갖음
  - 따라서 세컨더리 인덱스를 만들어도 해당 인덱스에는 PK 값이 포함되어 있어 커버링 인덱스로 처리될 가능성이 높음
- Using join buffer : 드리븐 테이블에 적절한 인덱스가 없어 블록 네스티드 루프 조인이나 해시 조인이 수행되었음을 의미한다
- Using temporary : `MySQL` 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용했음을 의미한다
  - 임시 테이블은 메모리상에 생성될 수도 있고 디스크 상에 생성될 수도 있음
  - 인덱스를 사용하지 못하는 `GROUP BY` 쿼리가 대표적인 예시
  - `Using temporary` 를 표시하지 않아도 내부적으로 임시 테이블을 사용했을 수도 있음 -> FROM 절의 서브쿼리, 인덱스를 사용할 수 없는 COUNT, 인덱스를 사용하지 못하는 정렬
- Using where : `MySQL` 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 수행했음을 의미한다
