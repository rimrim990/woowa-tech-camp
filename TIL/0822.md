# 우아한 테크 캠프 TIL - 2023.08.21 (화)

## 스프링 데이터 JPA 락 (4)

### 서문
쇼핑몰 프로젝트에서 동시성과 sql 튜닝을 위해 innoDB 스토리지 엔진을 더 파보자 !

### `InnoDB` 클러스터링 테이블
`InnoDB` 는 클러스터링 테이블 구조를 사용한다
- 레코드 (pk) 를 값이 비슷한 것들끼리 묶어서 저장한다
- 프라이머리 키에 의해 레코드가 저장될 위치가 결정되고, 프라이머리 키 값이 바뀌면 레코드의 저장 위치도 바뀐다

클러스터링 테이블의 구조는 `B-TREE` 와 비슷하지만, 클러스터링 테이블의 리프 노드에는 레코드의 모든 칼럼이 같이 저장되어 있다
- 세컨터리 인덱스는 `B-TREE` 구조를 사용한다
- 프라이머리 키나 이를 대체할 컬럼이 없으면 `InnoDB` 는 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가, 클러스터링 키로 선택
```
emp_no (pk) = 10001 -> (10001 ~ 10007) 레코드가 저장된 데이터 블록
emp_no (pk) = 10008 -> (10008 ~ 10009) 레코드가 저장된 데이터 블록
```

**세컨더리 인덱스**
- `InnoDB` 클러스터링 테이블을 사용하고 있으므로, 클러스터링 키 값이 바뀌면 데이터가 저장된 위치가 변경된다
  - 만약 세컨더리 인덱스에서 데이터가 저장된 위치를 저장한다면 모든 인덱스 리프 노드에 해당 변경 내용을 적용해야 함
- `InnoDB` 에서는 모든 세컨더리 인덱스는 해당 레코드가 저장된 위치가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다

```sql
CREATE TABLE employees (
  emp_no INT NOT NULL,
  first_name VARCHAR(20) NOT NULL,
  PRIMARY KEY (emp_no),
  INDEX ix_firstname (first_name) 
);

SELECT * FROM employees WHERE first_name = "Aamer";
```
- `ix_firstname` 인덱스를 조회하여 레코드의 프라이머리 키 값을 확인한다
- 프라이머리 키 인덱스를 검색해 최종 레코드를 가져온다

### `InnoDB` 인덱스 레코드 락
`InnoDB` 는 레코드에 락을 걸지 않고 **인덱스 레코드**에 락을 건다
- 변경해야 할 레코들르 찾기 위해 인덱스를 검색할 때, 검색한 인덱스의 레코드에 모두 락을 건다

`UPDATE` 문장에 사용될 적절한 인덱스가 준비되어 있지 않다면, 각 클라이언트 간의 동시성이 상당히 떨어지게 되어 클라이언트는 오래 기다리게 된다
- 테이블에 인덱스가 없으면 테이블을 풀 스캔하면서 `UPDATE 작업을 수행해야 하는데, 이 과정에서 테이블에 존재하는 모든 레코드를 잠그게 된다

**실습 - 적절한 인덱스가 없는 경우**
```
MySQL [shopping]> explain update products set stock = 10 where name like '%치킨%' and stock > 90;
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | UPDATE      | products | NULL       | index | NULL          | PRIMARY | 8       | NULL |    4 |   100.00 | Using where |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+

1 row in set, 1 warning (0.000 sec)
```
- 적절한 인덱스를 타지 않고 풀 스캔을 진행하는 다음의 `UPDATE` 쿼리를 수행하였다
- 해당 쿼리에 영향을 받는 레코드는 단 한 건만 존재한다

```sql
MySQL [shopping]> update products set price = 10000 where id = 34;
```
- 다른 트랜잭션에서 `UPDATE` 쿼리를 수행하였다
- 해당 쿼리는 앞서 탐색한 쿼리 결과에 포함되지는 않지만, 풀 스캔으로 인해 모든 인덱스 레코드에 락이 걸려 락을 획득할 때까지 기다려야 한다

**실습 - 적절한 인덱스가 존재하는 경우**
테이블의 기본 키인 `id` 에 대한 조건을 추가하여 `UPDATE` 쿼리를 수행하였다

```sql
MySQL [shopping]> update products set price = 10000 where id > 35;
Query OK, 1 row affected (0.001 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```
- id 가 35 보다 큰 인덱스 레코드에 대해 잠금을 수행한다

```sql
MySQL [shopping]> update products set price = 200000 where id = 33;
Query OK, 1 row affected (0.001 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```
- 다른 트랜잭션에서 해당 쿼리를 수행하면 기다림 없이 바로 갱신이 가능하다
- 해당 인덱스 레코드에 대해서는 잠금이 걸리지 않았기 때문이다

