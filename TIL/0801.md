# 우아한 테크 캠프

## 2023.08.01 (화) - TIL

### `static` 필드는 스프링 빈 주입이 불가능하다
**문제 상황**
- 쇼핑몰 미션 구현 중 JWT 암호화에 사용할 비밀키를 `@Value` 로 `private static String` 필드에 주입하였으나, 디버깅 결과 비밀키가 `null` 값을 갖고 있음

**문제 원인**
- `static` 필드는 스프링 컨텍스트로부터 빈 주입을 받지 못함
- 빈 주입을 담당하는 `AutowiredAnnotationBeanPostProcessor` 에서 다음과 같은 로그를 남긴다.

![스크린샷 2023-08-01 오후 9.47.52.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-01%20%EC%98%A4%ED%9B%84%209.47.52.png)

- `AutowiredAnnotationBeanPostProcessor` 의 다음 코드에서 위와 같은 로그를 남겼다.
```java
// 리플렉션으로 클래스의 모든 지역 변수 정보들을 가져온다.
ReflectionUtils.doWithLocalFields(targetClass, field -> {
    // @AutoWire 어노테이션을 선언한 static 필드일 경우 종료한다.
    if (Modifier.isStatic(field.getModifiers())) {
        if (logger.isInfoEnabled()) {
            logger.info("Autowired annotation is not supported on static fields: " + field);
        }
        return;
    }
});
```
- `static` 변수는 클래스가 로딩될 때 초기화된다.
- 스프링은 컨텍스트가 시작된 후, 빈 생성한 이후에 의존관계를 주입한다. 

**해결 방법**
- 스프링 `@Value` 주입을 위해 비밀키가 `static` 필드가 아니도록 수정한다.

### Java `Reflection`
- 자바 리플렉션 기능을 사용하여 클래스 생성자와 메서드, 필드 등의 정보를 자세히 알아낼 수 있다.
  - 프레임워크와 라이브러에서 사용되는 어노테이션도 리플렉션이 적용된 예
  - 리플렉션을 사용하면 클래스와 메서드에 어느 어노테이션이 붙었는지 알 수 있다
- 자바 리플렉션을 사용하여 컴파일 타임이 아닌 런타임에 클래스 정보를 추출할 수 있다.

**Java Doc**
- `Class` 객체는 `class` 파일의 바이트 코드로부터 클래스가 로딩될 때 JVM (클래스 로더) 에 의해 자동으로 생성된다.


**사용 방법**
1. 메모리에 로딩된 `Class` 타입을 가져온다
```java
// 런타임에 클래스 정보 추출
Class<?> clazz = Class.forName("nextstep.helloworld.core.di.TestClass");
```

2. 가져온 `Class` 타입을 통해 해당 클래스의 인스턴스를 생성할 수 있다.
```
// TestClass 생성자를 이용하여 인스턴스 생성
Constructor<?> constructor = clazz.getConstructor(String.class);
TestClass testClass = (TestClass) constructor.newInstance("hello");
```

3. 접근 제한자와 관계없이 필드와 메소드를 사용할 수 있다. .
```java
// TestClass 의 private 필드에 접근
Field testField = clazz.getDeclaredField("testField");
```