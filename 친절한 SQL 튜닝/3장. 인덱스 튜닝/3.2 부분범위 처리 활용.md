# 친절한 SQL 튜닝 (개발자를 위한 SQL 튜닝 입문서)

## 3장. 인덱스 튜닝

### 부분범위 처리 활용

**부분범위 처리**
- 인덱스를 사용하더라도, 인덱스로 액세스할 대상이 많아지면 테이블 랜덤 액세스로 인해 성능이 매우 떨어진다.
- 부분범위 처리를 활용하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼 수 있다.

**부분범위 처리 동작과정**
- DBMS 가 클라이언트에게 데이터를 전송할 때 **일정량씩 나누어 전송**한다.
- 전체 결과집합 중에서 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 `Fetch Call` 을 받기 전까지 기다린다.
  - 서버 프로세스는 일정량의 데이터만 전송하고 CPU 를 OS 에 반환하고 대기 큐에서 잠
  - 다음 `Fetch Call` 을 받으면 대기 큐에서 나와 다음 데이터부터 일정량을 읽어서 전송하고 또다시 잠을 잠
  - 데이터 전송 단위인 `ArraySize` 는 클라이언트 프로그램에서 설정

**정렬 조건이 있을때 부분범위 처리**
```java
Statement stmt = con.createStatement();
ResultSet rs = stmt.createQuary("select name from big_table order by created");
```
- DB 서버는 모든 데이터를 다 읽어 `created` 필드 순으로 정렬 한 후에야 클라이언트에게 데이터 전송을 시작할 수 있다. (전체범위 처리)
- `created` 컬럼이 선두인 인덱스가 있으면 부분범위 처리가 가능하다

**`ArraySize` 조정을 통한 `Fetch Call` 최소화**
- 네트웤르르 통해 전송해야 할 데이터량에 따라 `ArraySize`를 조절할 필요가 있다.
- 어차피 데이터를 모두 전송해야 한다면 가급적 값을 크게 설정해야 `Fetch Call` 횟수를 줄일 수 있다.
- 반면에 앞쪽 일부 데이터만 `Fetch` 하고 멈추는 프로그램이라면 `ArraySize` 를 작게 설정하는 것이 유리하다.

**부번범위 처리의 핵심**
- 앞쪽 일부만 출력하고 멈출 수 있는가의 여부가 부분범위 처리의 핵심이다.
- 클라이언트와 DB 서버 사이에 `WAS` 서버 등이 존재하는 `n-Tier` 아키텍처에서는 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
- 단위 작업을 마치면 DB 커넥션을 곧바로 커넥션 풀에 반환해아 하므로 그 전에 SQL 조회 결과를 클라이언트에게 '모두' 전송하고 커서를 닫아야 한다.
  - 따라서 SQL 결과집합을 조금씩 나눠 전송하도록 구현하기가 어려움
