# 친절한 SQL 튜닝 (개발자를 위한 SQL 튜닝 입문서)

## 3장. 인덱스 튜닝

### 테이블 액세스 최소화

**인덱스 `ROWID`**
- SQL 이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스 스캔 후 반드시 테이블 액세스가 필요하다.
- 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빠르게 찾고, 거기서 테이블 레코드를 찾아가기 위한 주소값인 `ROWID` 를 얻기 위함이다.

**데이터 블록 접근 과정**
- 디스크에 접근하기 전에 버퍼캐시부터 찾아본다.
- 읽고자 하는 DBA 를 해시 함수에 입력해서 해시 체인을 찾고, 거기서 버퍼 헤더를 찾는다.
  - 캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로 버퍼 헤더는 항상 같은 해시 체인에 연결됨
- 버퍼 헤더에서 얻은 포인터로 캐싱된 버퍼 블록을 찾아간다.
- 버퍼 캐시에 데이터 블록이 존재하지 않으면 디스크에서 블록을 버퍼 캐시에 적재한 후 읽는다.
- 모든 데이터가 캐싱되어 있더라도 매번 DBA 해싱과 래치 획득 과정을 반복해야 한다.

**클러스터링**
- 클러스터링 팩터가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다.
  - 클러스터링 팩터는 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
- 오라클은 `ROWID` 를 통해 얻은 데이터 블록에 대한 메모리 주소값을 바로 해제하지 않고 일단 유지한다.
- 이 상태에서 다음 인덱스 레코드를 읽었는데, 마침 직전과 같은 데이터 블록을 가리킨다면, 래치 획득과 해시 체인 스캔 과정을 생략하고 바로 테이블을 읽을 수 있다.
  - 논리적인 I/O 는 래치를 획득하고 해시 체인을 스캔하여 블록을 찾아가는 과정을 의미

**인덱스 손익분기점**
- 테이블 풀 스캔은 전체 데이터 중 몇 건을 읽던 항상 성능이 일정하다.
- 인덱스를 이용한 테이블 액세스는 전체 데이터 중 몇 건을 추출하냐에 따라 성능이 크게 달라진다.
  - 인덱스 스캔량이 늘기 때문에
  - 가장 큰 영향은 **테이블 랜덤 액세스**의 증가 때문

**Covered 쿼리**
- 인덱스만 읽어서 처리하는 쿼리를 `Covered` 쿼리라고 한다.
- 해당 쿼리에 사용한 인덱스를 `Covered` 인덱스라고 한다.

**클러스터 테이블**
- 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다.
- 클러스터 인덱스는 일반 인덱스처럼 `B-Tree` 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다.
  - 클러스터 인덱스의 키 값은 항상 유니크
- 인덱스 클러스터와 해시 클러스터가 존재한다.
- 하나의 키 값당 랜덤 I/O 가 한 번 밖에 발생하지 않는다.