# 친절한 SQL 튜닝 (개발자를 위한 SQL 튜닝 입문서)

## 2장. 인덱스 기본

### 인덱스 기본 사용법

**인덱스 레인지 스캔**
- 인덱스는 정렬돼 있기 때문에 스캔하다가 조건을 만족하지 않는 단어를 만나는 순간 멈출 수 있다.
- 인덱스가 가공되어 있다면 시작점을 찾을 수 없으며, 스캔하다가 중간에 멈출 수도 없다.
  - 가공한 값이나 중간값을 찾을 때도 색인을 찾을 수 있지만, 색인 전체를 스캔해야 함
- 인덱스 컬럼 (선두 컬럼) 을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- `OR` 이나 `IN` 조건으로 작성된 쿼리도 인덱스를 사용할 수 없다.
  - 옵티마이저의 쿼리 변환 기능을 통해 인덱스 레인지 스캔으로 처리하기도 함
  ```mysql
	select * from 고객 where (전화번호 = :tel_no or 고객명 = :cust_nm);
  
  // 옵티마이저의 Or Expansion
  select * from 고객 where 고객명 = :cust_nm
  union all
  select * from 고객 where 전화번호 = :tel_no
	```
  
**인덱스 사용 조건**
- 조건절에서 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.
- 인덱스 선두 컬럼이 조건절에 있어야 한다.
- 인덱스 레인지 스캔을 한다고 해서 항상 서능이 좋은 건 아니다.
  - 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 함

**인덱스를 이용한 소트 연산 생략**
- 테이블과 달리 인덱스는 정렬돼 있기 때문에 소트 연산을 생략할 수 있다.
- 옵티마이저는 SQL 에 `ORDER BY` 가 있어도 정렬 연산을 따로 수행하지 않는다.
  - 그러나 `ORDER BY` 또는 `SELECT-LIST` 에서 컬럼을 가공함으로 인덱스를 정상적으로 사용할 수 없는 경우도 있음
	```mysql
	select * from 상태변경이력 where 장비번호 = 'C' ORDER BY 변경일자 || 변경순번;
	```	
- 옵티마이저는 최소 / 최대 값을 구할 때 정렬 연산을 따로 수행하지 않는다.

**자동 형변환**
- 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS 가 있는가 하면, 자동으로 형변환 처리해주는 DBMS 도 있다. (ex. 오라클)
  - 자동 형변환을 통해 인덱스 컬럼이 가공되면 인덱스 레인지 스캔 불가
- 자동 형변환 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 한다.
- 형변환을 생략한다고 SQL 성능을 향상시킬 수 없다. SQL 성능은 블록 I/O 를 줄일수 있는냐 없느냐에서 결정된다.
  - 개발자가 형변환 함수를 생략해도 옵티마이저가 자동으로 생성함