# 성공과 실패를 결정하는 1%의 네트워크 원리
## Chapter 01. 웹 브라우저가 메시지를 만든다
### 04. 프로토콜 스택에 메시지 송신을 의뢰한다

브라우저는 사용자가 입력한 url 로부터 IP 주소를 조회하고, IP 주소에 해당하는 웹 서버에 메시지를 송신하기 위해 OS 내부에 있는 프로토콜 스택에 의뢰한다.

**프로토콜 스택**
- 프로토콜 스택은 OS 에 내장되어 있는 네트워크 제어용 소프트웨어를 의미한다
  - 구체적으로는 `TCP/IP` 를 의미
- 브라우저로부터 받은 메시지를 패킷에 저장하고 제어 정보를 덧붙인다
- 통신 오류가 발생핬을 때 오류로부터 복구한다
- 프로토콜 스택은 패킷을 LAN 어댑터에에 넘기고, LAN 어댑터가 이를 전기 신호로 변환하고 LAN 케이블에 송출한다

**소켓**

<img src="http://jkkang.net/unix/netprg/chap2/xtrsq001.gif">

- 호스트 프로세스와 프로토콜 스택 간에 데이터를 주고 받는 출입구를 `소켓` 이라고 부른다
  - 응용 프로그램은 소켓을 통해 데이터를 송, 수신
  - 즉, 소켓은 응용 프로그램에서 `TCP/IP` 프로토콜 스택을 이용하기 위한 창구 역할
- 서버측에서 먼저 소켓을 만들고, 클라이언트가 소켓에 연결하기를 기다린다
- 클라이언트 측에서 소켓을 생성하고 서버측 소켓과 연결한다
- 소켓을 통해 데이터를 전송하며 데이터 송, 수신 동작을 실행한다

**데이터 송, 수신**
1) 소켓 생성
2) 클라이언트 소켓을 서버측 소켓과 연결
3) 데이터 송, 수신
4) 소켓 연결을 종료하고 소켓 말소

**소켓 생성**
- `socket` 을 호출하면 내부로 제어가 넘어간다
- 소켓이 생성되면 `디스크립터` 반환하고, 애플리케이션은 이를 메모리에 기록해둔다
  - 소켓 디스크립터는 프로그램 실행 중에 열린 다양한 소켓 중에서 현재 사용중인 소켓을 식별하기 위해 필요
- `socket()` 시스템 콜을 호출하여 소켓을 생성할 수 있다

```
int socket (
	int domain, 	/* 프로토콜 체계 ex) AF_INET */
	int type, 		/* 서비스 타입 ex) SOCK_STREAM, SOCK_DGRAM */
	int protocol 	/* 소켓에 사용될 프로토콜 ex) SOCK_NONBLOCK */
);
```
- `TCP/IP` 프로토콜을 사용하려면 `PF_INET` (IPv4 인터넷 프로토콜), `SOCK_STREAM` (스트림 방식의 소켓) 해야한다

**소켓 디스크립터**
- `UNIX` 운영체제에서는 파일을 새로 열면 `int` 타입의 정수를 리턴하는데, 이를 파일 디스크립터라고 한다
  - 프로그램에서 열린 파일에 접근할 때 파일 디스크립터를 이용한다

<img src="http://jkkang.net/unix/netprg/chap2/xtrsq002.gif">

- 파일 디스크립터는 디스크립터 테이블의 인덱스 번호이다
  - 디스크립터 테이블은 현재 프로그램에서 연 파일의 각종 정보를 포함하고 있는 구조체를 가리키는 포인터들로 구성된 테이블이다
  - 디스크립터 테이블은 프로세스마다 존재한다
- 프로그램에서 소켓을 열먼 파일 디스크립터와 똑같은 기능을 하는 소켓 디스크립터를 반환한다

<img src="http://jkkang.net/unix/netprg/chap2/xtrsq003.gif">

- 소켓번호는 응용 프로그램 내에서 순서대로 배정되며, 해당 프로그램 내에서만 유일하게 구분되면 된다
  - 서로 다른 응용 프로그램에서 같은 소켓번호를 사용하는 것은 문제가 되지 않음
  - 디스크립터는 오름차순으로 부여된다
- 포트번호는  `TCP/IP` 가 지원하는 상위 계층의 프로세스를 구분하기 위한 번호이므로 하나의 컴퓨터 내에 있는 응용 프로세스들은 반드시 서로 다른 포트번호를 사용해야 한다

**소켓 연결하기**
- 응용 프로그램은 `connect` 시스템 콜을 호출하여 서버측의 소켓과 연결을 시도할 수 있다

```
int connect (
	int 			sockfd,	/* 연결할 소켓의 파일 디스크립터 */
	struct sockaddr *addr, 	/* 소켓과 연결할 주소 */
	socklen_t 		addrlen	/* addr 길이 */
);
```

- `sockfd` 디스크립터가 가리키는 소켓을 `addr` 와 연결한다
- `addr` 는 DNS 서버에 조회하여 알아낸 서버의 IP 주소와 포트 번호이다
  - IP 주소로 네트워크에 존재하는 호스트 (네트워크 하드웨어) 를 식별할 수 있음
  - IP 주소 + 포트 번호로 어떤 소켓과 데이터를 송, 수신할지 정할 수 있음
- 클라이언트 측 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택에 의해 결정된다
- `connect` 호출로 서버와 연결되면 프로토콜 스택은 연결된 상대의 IP 주소 (`remote IP`) 와 포트 번호 (`remote port`) 등의 정보를 소켓에 기록한다

**데이터 송, 수신**
- 소켓이 서버와 연결되면, 소켓에 데이터를 작성하면 상대측 소켓에 데이터가 도착한다
- 응용 프로그램은 `send` 시스템 콜을 통해 프로토콜 스택에 데이터 전송을 의뢰한다
  - 1) 전송할 데이터를 메모리에 준비한다 ex) 사용자가 입력한 url 바탕으로 생성한 HTTP 리퀘스트 메시지
  - 2) 파일 디스크립터와 전송할 데이터를 지정하여 `send` 를 호출 -> 버퍼에서 `len` 만큼의 데이터를 읽어간다
  - 3) 소켓에는 서버의 주소와 포트 번호가 저장되어 있으므로, 해당 정보를 기반으로 OS 가 소켓으로 데이터 전송

```
ssize_t send (
	sockfd,
	buf,
	len
);
```

- 응용 프로그램은 `recv` 시스템 콜을 통해 프로토콜 스택에 데이터 수신을 의뢰한다
  - 1) 수신한 응답 메시지를 저장하기 위한 메모리 영역인 `수신 버퍼` 를 지정한다
  - 2) 응답 메시지가 돌아올 때 `recv` 가 이를 수신 버퍼에 저장한다
      - 소켓 버퍼에서 읽어올 메시지가 없다면 `receive` 는 메시지가 도착하기를 기다린다
  - 3) 수신 버퍼는 응용 프로그램에게 할당된 메모리 영역이므로 수신 버퍼에 메시지를 저장함으로써 메시지를 어플리케이션에 건네준다

```
ssize_t recv (
	sockfd,
	buf,
	len
);
```

**소켓 연결 종료, 말소**
- `close` 시스템 콜을 호출하여 프로토콜 스택에 연결 종료를 의뢰할 수 있다
  - 디스크립터 할당을 해제하여 다시 사용가능하도록 한다
  - 소켓에 할당된 모든 데이터를 해제한다
```
int close (
  int socket
);
```
